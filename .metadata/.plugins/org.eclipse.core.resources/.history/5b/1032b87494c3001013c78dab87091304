/*
 * u2_jobs.c
 *
 *  Created on: 14-Nov-2025
 *      Author: mad23
 */

#include "u2_jobs.h"
#include "queues.h"
#include "proto.h"
#include "sched.h"
#include <stdint.h>
#include <stdbool.h>
#include <string.h>   // for memset

/* Optional safety cap for stack mask buffers used in multi-mask. */
#ifndef U2_MAX_MASK_LEN
#define U2_MAX_MASK_LEN 120
#endif

volatile U2Job g_u2_jobs[MAX_U2_JOBS];
uint8_t u2_jobs_rr = 0;

/* Normalize to 1..60 (61->1, 63->3, 120->60); 0 stays 0. */
static inline uint8_t u2_norm_led(uint8_t led) {
    if (led == 0)  return 0;
    if (led <= 60) return led;
    return (uint8_t)(led - 60);
}

/* ---------------- Job table ops ---------------- */

void u2_job_start(uint8_t bin, uint8_t led){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i){
        if (g_u2_jobs[i].active && g_u2_jobs[i].bin==bin && g_u2_jobs[i].led==led){
            g_u2_jobs[i].next_allowed_tick = (uint16_t)g_tick; return;
        }
    }
    for (uint8_t i=0;i<MAX_U2_JOBS;++i){
        if (!g_u2_jobs[i].active){ g_u2_jobs[i]=(U2Job){bin,led,(uint16_t)g_tick,1}; return; }
    }
}

void u2_jobs_stop_by_led(uint8_t led){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i)
        if (g_u2_jobs[i].active && g_u2_jobs[i].led==led) g_u2_jobs[i].active=0;
}

void u2_jobs_stop_all(void){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i) g_u2_jobs[i].active=0;
}

void u2_jobs_remove_by_bin_except(uint8_t bin, uint8_t keep_led){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i)
        if (g_u2_jobs[i].active && g_u2_jobs[i].bin==bin && g_u2_jobs[i].led!=keep_led) g_u2_jobs[i].active=0;
}

uint8_t u2_job_find(uint8_t bin, uint8_t led){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i)
        if (g_u2_jobs[i].active && g_u2_jobs[i].bin==bin && g_u2_jobs[i].led==led) return i;
    return 0xFF;
}

/* ---------------- UART2 frame enqueue ---------------- */

void bin_enqueue_led_on_uart2(uint8_t bin, uint8_t led){
    /* Single LED path keeps your previous normalization behavior. */
    led = u2_norm_led(led);
    uint8_t f[9] = { SOF, GRP_RX_TO_SLV, 0x05, SC_SLAVE, bin, 0x04, 0x01, led, END_BYTE };
    (void)u2q_push_isr(f, sizeof f);
}

void bin_enqueue_led_off_broadcast_uart2(void){
    uint8_t f[8] = { SOF, GRP_RX_TO_SLV, 0x04, SC_SLAVE, 0xFF, 0x03, 0x00, END_BYTE };
    (void)u2q_push_isr(f, sizeof f);
}

/* Helper: send a multi-mask frame with a prepared payload (zeros = skip) */
static void u2_send_compact_frame(uint8_t bin_id, uint8_t count, const uint8_t *vals) {
    if (!count) return;

    U2Frame fr;
    uint8_t *p = fr.data;

    *p++ = SOF;
    *p++ = GRP_RX_TO_SLV;
    *p++ = (uint8_t)(3 /*SC,bin,sub*/ + 1 /*count*/ + count);
    *p++ = SC_SLAVE;
    *p++ = bin_id;     // 1 or 2
    *p++ = 0x04;       // BIN subcode
    *p++ = count;      // number of entries (compact)

    for (uint8_t i = 0; i < count; ++i) *p++ = vals[i];

    *p++ = END_BYTE;
    fr.len = (uint8_t)(p - fr.data);
    (void)u2q_push_isr(fr.data, fr.len);
}

/*
 * Split the list into two frames:
 *  - Bin 1: entries <= 60 (kept as-is)
 *  - Bin 2: entries > 60 (normalized to 1..60)
 * Positions are preserved; 0 means "skip" in that position.
 */
void bin_enqueue_multi_mask_uart2(uint8_t max_led, const uint8_t *list){
    if (!max_led) return;

#ifndef U2_MAX_MASK_LEN
#define U2_MAX_MASK_LEN 120
#endif
    if (max_led > U2_MAX_MASK_LEN) max_led = U2_MAX_MASK_LEN;

    // Build COMPACT arrays (no zeros)
    uint8_t bin1_vals[U2_MAX_MASK_LEN];  // <=60, unchanged
    uint8_t bin2_vals[U2_MAX_MASK_LEN];  // >60, subtract 60
    uint8_t n1 = 0, n2 = 0;

    for (uint8_t i = 0; i < max_led; ++i){
        uint8_t l = list[i];
        if (l == 0) continue;

        if (l <= 60) {
            if (n1 < U2_MAX_MASK_LEN) bin1_vals[n1++] = l;
        } else {
            uint8_t reduced = (uint8_t)(l - 60);   // single subtract rule
            if (reduced == 0) continue;            // safety, though 61->1 so won't be 0
            if (n2 < U2_MAX_MASK_LEN) bin2_vals[n2++] = reduced;
        }
    }

    // Send only if there are entries; payload has NO zeros and count matches length
    if (n1) u2_send_compact_frame(1, n1, bin1_vals);
    if (n2) u2_send_compact_frame(2, n2, bin2_vals);
}

/* ---------------- Scheduler ---------------- */

bool u2_scheduler_emit_one(void){
    for (uint8_t k=0;k<MAX_U2_JOBS;++k){
        const uint8_t i = (uint8_t)((u2_jobs_rr + k) % MAX_U2_JOBS);
        if (!g_u2_jobs[i].active) continue;

        const bool time_ok = ((int16_t)((uint16_t)g_tick - g_u2_jobs[i].next_allowed_tick) >= 0);
        if (time_ok){
            bin_enqueue_led_on_uart2(g_u2_jobs[i].bin, g_u2_jobs[i].led);
            g_u2_jobs[i].next_allowed_tick = (uint16_t)(g_tick + 1);
            u2_jobs_rr = (uint8_t)((i + 1) % MAX_U2_JOBS);
            return true;
        }
    }
    return false;
}
