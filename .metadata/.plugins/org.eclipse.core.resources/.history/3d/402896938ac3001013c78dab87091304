/*
 * u2_jobs.c
 *
 *  Created on: 14-Nov-2025
 *      Author: mad23
 */

#include "u2_jobs.h"
#include "queues.h"
#include "proto.h"
#include "sched.h"
#include <stdint.h>
#include <stdbool.h>
#include <string.h>   // for memset

/* Optional safety cap for stack mask buffers used in multi-mask. */
#ifndef U2_MAX_MASK_LEN
#define U2_MAX_MASK_LEN 120
#endif

volatile U2Job g_u2_jobs[MAX_U2_JOBS];
uint8_t u2_jobs_rr = 0;

/* Normalize to 1..60 (61->1, 63->3, 120->60); 0 stays 0. */
static inline uint8_t u2_norm_led(uint8_t led) {
    if (led == 0)  return 0;
    if (led <= 60) return led;
    return (uint8_t)(((led - 1u) % 60u) + 1u);
}

/* ---------------- Job table ops ---------------- */

void u2_job_start(uint8_t bin, uint8_t led){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i){
        if (g_u2_jobs[i].active && g_u2_jobs[i].bin==bin && g_u2_jobs[i].led==led){
            g_u2_jobs[i].next_allowed_tick = (uint16_t)g_tick; return;
        }
    }
    for (uint8_t i=0;i<MAX_U2_JOBS;++i){
        if (!g_u2_jobs[i].active){ g_u2_jobs[i]=(U2Job){bin,led,(uint16_t)g_tick,1}; return; }
    }
}

void u2_jobs_stop_by_led(uint8_t led){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i)
        if (g_u2_jobs[i].active && g_u2_jobs[i].led==led) g_u2_jobs[i].active=0;
}

void u2_jobs_stop_all(void){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i) g_u2_jobs[i].active=0;
}

void u2_jobs_remove_by_bin_except(uint8_t bin, uint8_t keep_led){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i)
        if (g_u2_jobs[i].active && g_u2_jobs[i].bin==bin && g_u2_jobs[i].led!=keep_led) g_u2_jobs[i].active=0;
}

uint8_t u2_job_find(uint8_t bin, uint8_t led){
    for (uint8_t i=0;i<MAX_U2_JOBS;++i)
        if (g_u2_jobs[i].active && g_u2_jobs[i].bin==bin && g_u2_jobs[i].led==led) return i;
    return 0xFF;
}

/* ---------------- UART2 frame enqueue ---------------- */

void bin_enqueue_led_on_uart2(uint8_t bin, uint8_t led){
    /* Single LED path keeps your previous normalization behavior. */
    led = u2_norm_led(led);
    uint8_t f[9] = { SOF, GRP_RX_TO_SLV, 0x05, SC_SLAVE, bin, 0x04, 0x01, led, END_BYTE };
    (void)u2q_push_isr(f, sizeof f);
}

void bin_enqueue_led_off_broadcast_uart2(void){
    uint8_t f[8] = { SOF, GRP_RX_TO_SLV, 0x04, SC_SLAVE, 0xFF, 0x03, 0x00, END_BYTE };
    (void)u2q_push_isr(f, sizeof f);
}

/* Helper: send a multi-mask frame with a prepared payload (zeros = skip) */
static void u2_send_mask_frame(uint8_t bin_id, uint8_t max_led, const uint8_t *payload) {
    if (!max_led) return;

    U2Frame fr; uint8_t *p = fr.data;

    *p++ = SOF;
    *p++ = GRP_RX_TO_SLV;
    *p++ = (uint8_t)(3 + 1 + max_led);  /* SC_SLAVE, bin, subcode, count, payload[max_led] */
    *p++ = SC_SLAVE;
    *p++ = bin_id;                      /* 1 or 2 */
    *p++ = 0x04;                        /* BIN subcode */
    *p++ = max_led;

    for (uint8_t i = 0; i < max_led; ++i) *p++ = payload[i];

    *p++ = END_BYTE;
    fr.len = (uint8_t)(p - fr.data);
    (void)u2q_push_isr(fr.data, fr.len);
}

/*
 * Split the list into two frames:
 *  - Bin 1: entries <= 60 (kept as-is)
 *  - Bin 2: entries > 60 (normalized to 1..60)
 * Positions are preserved; 0 means "skip" in that position.
 */
void bin_enqueue_multi_mask_uart2(uint8_t max_led, const uint8_t *list){
    if (!max_led) return;

    /* Cap to a safe stack buffer length if needed. */
    if (max_led > U2_MAX_MASK_LEN) max_led = U2_MAX_MASK_LEN;

    uint8_t has_bin1 = 0, has_bin2 = 0;

    /* Build and send bin-1 payload (<=60) */
    uint8_t mask1[U2_MAX_MASK_LEN];
    memset(mask1, 0, max_led);
    for (uint8_t i = 0; i < max_led; ++i){
        uint8_t l = list[i];
        if (l != 0 && l <= 60){
            mask1[i] = l;  /* keep as-is */
            has_bin1 = 1;
        }
    }
    if (has_bin1) u2_send_mask_frame(1, max_led, mask1);

    /* Build and send bin-2 payload (>60, normalized) */
    uint8_t mask2[U2_MAX_MASK_LEN];
    memset(mask2, 0, max_led);
    for (uint8_t i = 0; i < max_led; ++i){
        uint8_t l = list[i];
        if (l > 60){
            mask2[i] = u2_norm_led(l);  /* 61->1, 63->3, ..., 120->60 */
            has_bin2 = 1;
        }
    }
    if (has_bin2) u2_send_mask_frame(2, max_led, mask2);
}

/* ---------------- Scheduler ---------------- */

bool u2_scheduler_emit_one(void){
    for (uint8_t k=0;k<MAX_U2_JOBS;++k){
        const uint8_t i = (uint8_t)((u2_jobs_rr + k) % MAX_U2_JOBS);
        if (!g_u2_jobs[i].active) continue;

        const bool time_ok = ((int16_t)((uint16_t)g_tick - g_u2_jobs[i].next_allowed_tick) >= 0);
        if (time_ok){
            bin_enqueue_led_on_uart2(g_u2_jobs[i].bin, g_u2_jobs[i].led);
            g_u2_jobs[i].next_allowed_tick = (uint16_t)(g_tick + 1);
            u2_jobs_rr = (uint8_t)((i + 1) % MAX_U2_JOBS);
            return true;
        }
    }
    return false;
}
